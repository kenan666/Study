'''
给定一个未排序的整数数组，找出其中没有出现的最小的正整数。

示例 1:

输入: [1,2,0]
输出: 3
示例 2:

输入: [3,4,-1,1]
输出: 2
示例 3:

输入: [7,8,9,11,12]
输出: 1
说明:

****************************************************
你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。

'''
#  直接求解法  集合法
def firstMissingPositive(self, nums: List[int]) -> int:
    i = 1
    nums = set(nums)
    while i in nums :
        i += 1
    return i

'''
此时时间复杂度较低，但是空间复杂度较高O(n) ，如果先进性排序，时间复杂度不满足要求

'''
'''
优化解：
1. 现有空间 2. 要扫数组两次.

所以,这里我们有个小技巧,把数组的索引号利用起来,如果我们把位置0我们放数字1,位置1我们放数字2...我们就可以节省存储索引的空间了,按照这样的方法重新整理数组,再扫一次

比如示例中的:[3,4,-1,1]

第一步,数字3它应该放在位置2 ,交换位置,[-1,4,3,1]

第二步,数字4应该放在位置3,交换位置,[-1,1,3,4],此时有个关键,数字1应该在位置0,所以我们继续交换,[1,-1,3,4]

...

我们再次扫数组,就能得到结果.

所以,时间复杂度:O(2n)O(2n),空间复杂度:O(1)O(1)

'''
def firstMissingPositive(self, nums: List[int]) -> int:
    n = len(nums)
    for i in range (n):
        while 1<= nums[i] and nums[nums[i] - 1] != nums[i]:
            nums[nums[i] - 1],nums[i] = nums[i],nums[nums[i] - 1]
        
    i = 0
    while i<n and i + 1 == nums[i]:
        i += 1
    
    return i+1
