# ------------------------动态规划-----------------------
'''
--------------
概念：
--------------

动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，
以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

-----------
概述：
-----------
1、动态规划在查找有很多重叠子问题的情况的最优解时有效。它将问题重新组合成子问题。
   为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。

2、动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。
   简单地说，问题能够分解成子问题来解决。

-----------
适用情况：
-----------
1、最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。

2、无后效性。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。

3、 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。
    动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，
    只是在表格中简单地查看一下结果，从而获得较高的效率。

---------------->>> 经典问题  背包问题  ** 添加补充

计算式来源于  斐波那契算数
        fib(n-1) +fib(n-2)  n>2
fib(n) = 
        1  n=1/2

实际概念：求最大值--求最优解**
            选    V(i) + OPT(preV(i))
OPT(i) =max 
            不选  OPT(i-1)

两种情况  opt(0) = arr[0]    opt(1) = max(arr[0],arr[1])

'''
#------------例1----------------------
'''
选择一些数字，使得和最大。
* 选择某个数字后，则不能选择相邻数字
例：
4    1    1    9    1
^    _   ---> 此时 4 后的 1 则不能选择，可选其他数字

          _    ^    _  ---->选择 9 之后，则两边 1 都不能进行选择，可选其他数字
'''

'''
例：
        0    1    2    3    4    5    6 
arr     1    2    4    1    7    8    3

假设                                 opt(6)
                                +/                 \-
               max      opt(4)+arr[6]             opt(5)       
                      +/           \-         +/             \- 
            max  opt(2)+arr[4]    opt(3)   max opt(3)+arr[5]  opt(4)

此时opt(4)   与  opt(3)  是重复子问题

得到公式：
            选 -->  A = opt(i-2) + arr[i]
opt(i) = max
            不选  --> B = opt(i-1)

opt(0) = arr[0]
opt(1) = max(arr[0],arr[1])

'''
#----------------解1--》递归--------------
arr = [1,2,4,1,7,8,3]
def rec_opt(arr,i):
    if i == 0:
        return arr[0]
    elif i == 1:
        return max(arr[0],arr[1])
    else:
        A = rec_opt(arr,i-2) + arr[i]
        B = rec_opt(i-1)
        return max(A,B)

#-------------非递归--------------------
import numpy as np
arr = [1,2,4,1,7,8,3]
def dp_opt(arr,i):
    opt = np.zeros(len(arr))
    opt[0] = arr[0]
    opt[1] = max(arr[0],arr[1])
    for i in range (2,len(arr)):
        A = opt[i-2] + arr[i]
        B = opt[i-1]
        opt[i] = max(A,B)
    return opt[len(arr) - 1]

'''
例2：
        0    1    2    3    4        target = S = 9 
arr     3    4    12   5    2    

subset(i,S)                      subset(arr[i],S)
                            +/                          \-
                    subset(arr,i-1,S-arr[i-1])   or  subset(arr[i],S)
                    
1、如果 subset(arr[2],0)   如果所需要的 S 为  0 ：
则--->  if s==0: return True

2、 如果  subset(arr[i],s)   --->  arr[0] == s
则： ---->   if i == 0 : return arr[0] == s

3、 if arr[i] > s:  ---->  此时只考虑不选那种情况
则： ---> return subset(arr[i-1],S)
                    选  subset(arr,i-1,s-arr[i])
subset(arr,i,s) = 
                    不选 subset (arr,i-1,S)
'''
# -------------解1 --递归-----------------------
arr = [3,4,12,5,2]
def rec_subset(arr,i,s):
    if s == 0:
        return True
    elif i == 0:
        return arr[0] == s
    elif arr[i] == s:
        return rec_subset(arr,i-1,s)
    else:
        A = rec_subset(arr,i-1,s-arr[i])
        B = rec_subset(arr,i-1,s)
        return A or B

#--------非递归--------------------------------
import numpy as np
arr = [3,4,12,5,2]
def dp_subset(arr,S):

    subset = np.zeros((len(arr),S+1),dtype=bool)
    subset[:,0] = True
    subset[0,:] = False
    subset[0,arr[0]] = True

    for i in range (1,len(arr)):
        for s in range (1,S+1):
            if arr[i] > s:
                subset[i,s] = subset[i-1,s]
            else:
                A = subset[i-1,s-arr[i]]
                B = subset[i-1,s]
                subset[i,s] = A or B
    r,c = subset.shape
    return subset[r-1,c-1]
#------------------------------------------------------------------------------------------------------------------
# 以上动态规划小实例分析，求最大值或者最优解，基本都是动态规划问题，可用递归或者非递归函数进行求解
# 实际运用中，递归会循环求解子问题，非递归则不会求解，相对来说，递归代码比较容易实现
# -----------------------------------------------------------------------------------------------------------------   
'''
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

示例 1:

输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1
示例 2:

输入: coins = [2], amount = 3
输出: -1
说明:
你可以认为每种硬币的数量是无限的。

'''
#-----------动态规划问题求解------------------------
# ----------------思考1----------------------------
'''
假设 f(n) 代表要凑齐金额为 n 所要用的最少硬币数量，那么有：

f(n) = min(f(n - c1), f(n - c2), ... f(n - cn)) + 1
其中 c1 ~ cn 为硬币的所有面额。

示例：
输入: coins = [1, 2, 5], amount = 11
输出: 3 
解释: 11 = 5 + 5 + 1

题目求的值为 f(11)，第一次选择硬币时我们有三种选择。

假设我们取面额为 1 的硬币，那么接下来需要凑齐的总金额变为 11 - 1 = 10，
即 f(11) = f(10) + 1，这里的 +1 就是我们取出的面额为 1 的硬币。

同理，如果取面额为 2 或面额为 5 的硬币可以得到：

f(11) = f(9) + 1
f(11) = f(6) + 1

所以：
f(11) = min(f(10), f(9), f(6)) + 1

'''
def coinChange(self, coins, amount):
    
    res = [0 for _ in range(amount + 1)]
    
    for i in range(1, amount + 1):
        cost = float('inf')
        for c in coins:
            if i - c >= 0:
                cost = min(cost, res[i - c] + 1)
        res[i] = cost
    
    if res[amount] == float('inf'):
        return -1
    else:
        return res[amount]

#  dp[i] = 1 +min(dp[i-coins[0]],di[i-coins[1]],dp[i-coins[2]]...)
def coinChange(self, coins: List[int], amount: int) -> int:
    if amount ==0:   # 总数为0，消耗钱为0
        return 0
    if amount < min(coins):   # 总数比所有的硬币面值都小，无解
        return -1
    dp = [0 for i in range(amount+1)]
    for coin in coins:        # 初始化dp数组
        if coin<=amount:
            dp[coin]= 1
    for i in range(1,amount+1):
        if dp[i]==1:
            continue
        min_ = 100000
        for j in coins:
            if i-j>0:
                min_ = min(min_,dp[i-j]+1)        
        dp[i] = min_
    if dp[-1]<100000:
        return dp[-1]
    else:
        return -1

#--------------硬币找零问题----------------------
'''
类型1  找出最少硬币数----组成一个值
题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。（你可以认为每种硬币的数量是无限的。）

'''
#------解法------
'''
对于一个金额，与它的差值为硬币库（coins）中硬币面值的数都是它一步就可以到达的，这里一步到达是指只需要一个硬币就能解决。
因此，对于一个金额，能够满足题目要求的硬币数为所有能够一步到达这个它的金额所需的硬币数加1。

例如：
coins = [1,2,5] , amount = 10

金额         1    2    3    4    5    6    7    8    9    10
最少金币     1    1    2    2    1    2    2    3    3    2
                            dp[10-5]    dp[10-2] dp[10-1]| 
                                |______________|____|    |
                                        |________________|
                                            最小值 +1
'''
#---------------------------------------------------------------------
# 动态规划方程
# dp[i] = 1 +min(dp[i-coins[0]],di[i-coins[1]],dp[i-coins[2]]...)  
#---------------------------------------------------------------------
def coinChange(self, coins: List[int], amount: int) -> int:
    dp = [float("inf") for i in range (amount + 1)]  # 初始化 dp数组
    dp[0] = 0
    for i in range (1,amount + 1):
        for coin in coins :
            if i - coin >= 0 :
                dp[i] = min(dp[i],dp[i-coin]+1)
    if dp[-1] == float("inf"):
        return -1 
    else:
        return dp[-1]

#--------------类型2----------------------
#------------找出最少的硬币--组成所有的面值---------------------------
'''
2019年腾讯开发岗实习生笔试的第一题
题目描述：
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成[1, amount]中所有面值所需的最少的硬币个数。
如果没有任何一种硬币组合能组成总金额，返回 -1。（你可以认为每种硬币的数量是无限的)。

'''
'''
这种情况比较复杂，组成所有范围内的面值。
最少硬币数（组成所有面值）----> 动态规划

例如：
coins = [1,2,5] , amount = 10 , 面值范围[1,10]

  金额    1    2    3    4    5    6    7    8    9    10
最少金币  1    2    2    3    3    4    4    5    4    4
                        ^
以 dp[4] 为例：
1、首先：dp[4] = min(dp[1] + dp[4-1], dp[2] + dp[4-2]);
2、由于硬币 2 在硬币库中，并且另一个dp[2]是可以组成[1.2-1]中所有面值的，因此，其中一个dp[2]可以直接用 1 代替，因此，
   dp[4] = min(dp[1]+dp[3],dp[2]+1) = 3

--------------------------
关于何时用一个硬币代替其中一个dp值应该满足条件：比如：dp[i] + dp[j] ,只要 i >= j-1 ,理论上dp[i]就可以组成[1,j-1]中所有值，
这种情况下，若j在硬币库中，则可以直接用一个硬币表示。
--------------------------
'''
def coinChange(self, coins: List[int], amount: int) -> int:
    dp = [float("inf") for i in range (amount + 1)]  # 初始化dp数组
    dp[0] = 0   # 当amount=0时，硬币所需要数为0
    if 1 not in coins:  # 如果硬币里面没有面值为1的硬币，则无法组成所有的硬币
        return -1
    dp[1] = 1
    for i in range(2,amount+1):
        min_ = dp[i]
        for j in range (1,i):
            if j in coins and j <= i-j+1:  # 如果另一部分直接可以用一个硬币代替
                min_ = min(min_,dp[i-j]+1)
            else:
                min_ = min(min_,dp[i-j] + dp[j])
        dp[i] = min_
    return dp[-1]