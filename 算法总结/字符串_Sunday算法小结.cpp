///************************字符串_Sunday算法小结*****************************字符串_Sunday算法小结
/*
sunday 算法再字符串匹配过程中，关注的是参加匹配的最末尾字符的（下一位）字符

如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；
否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。

例子     
假定  主串  substring searching
    模式串  search-          ///////此种横线表示关注的下一个字符

---> 结果发现在第2个字符处发现不匹配，不匹配时关注主串中参加匹配的最末位字符的下一位字符，即标粗的字符 i，因为模式串search中并不存在i，
      所以模式串直接跳过一大片，向右移动位数 = 匹配串长度 + 1 = 6 + 1 = 7，从 i 之后的那个字符（即字符n）开始下一步的匹配，
      
    如下图： 
    主串 substring searching
  模式串        search-

---> 结果第一个字符就不匹配，再看主串中参加匹配的最末位字符的下一位字符，是’r’，它出现在模式串中的倒数第3位，
     于是把模式串向右移动3位（m - 3 = 6 - 3 = r 到模式串末尾的距离 + 1 = 2 + 1 =3），使两个’r’对齐，
     
     如下： 
     主串 substring searching
   模式串           search     /////////配对成功

************
移动两次模式串就找了配对位置，每一步移动量都比较大，效率较高
 */

//----------------------------------------算法1---------------------------------------
const int maxNum = 1005;
int shift[maxNum];
int Sunday(const string & T ,const string & P)
{
    int n = T.length();
    int m = P.length();

    // 默认值，移动  m+1  位
    for (int i = 0; i<maxNum;i++)
    {
        shift[i] = m+1;
    }
    // 模式串P中每个字母出现的最后的下标
    // 所对应的主串参与匹配的最末位字符的下一位字符移动到该位，所需要的移动位数
    for (int i = 0; i<m;i++)
    {
        shift[P[i]] = m - i;
    }

    //模式串开始位置在主串的位置
    int s = 0;
    
    // 模式串已经匹配到的位置
    int j;
    while(s <= n-m)
    {
        j = 0;
        while(T[s+j] == P[j])
        {
            j++;
            //匹配成功
            if (j>=m)
            {
                return s;
            }
        }
        // 找到主串中当前跟模式串匹配的最末字符的下一个字符
        // 在模式串中出现最后的位置
        // 所需要从(模式串末尾+1)移动到该位置的步数
        s += shift[T[s + m]];
    }
    return -1;
}

//------------------------------------------算法2-------------------------
 int strStr(string haystack, string needle)
 {
    if(needle.empty())
        return 0;
    
    int slen = haystack.size();
    int tlen = needle.size();
    int i = 0,j = 0;  // i指向源串首位，j指向子串首位
    int k;
    int m = tlen;

    for (;i<slen;)
    {
        if (haystack[i] != needle[j])
        {
             for(k=tlen-1;k>=0;k--)//遍历查找此时子串与源串[i+tlen+1]相等的最右位置
                {
                    if(needle[k]==haystack[m])
                        break;
                }
                i=m-k;//i为下一次匹配源串开始首位 Sunday算法核心：最大限度跳过相同元素
                j=0;//j依然为子串首位
                m=i+tlen;//m为下一次参与匹配的源串最后一位元素的下一位
                if(m>slen)//当下一次参与匹配的源串字数的最后一位的下一位超过源串长度时
                    return -1;
        }
        else
        {
            if ( j == tlen - 1 ) //若j为子串末位 匹配成功 返回源串此时匹配首位
                return i - j;
            i++;
            j++;
        }
    }
    return -1; // 超过源串长度
 }