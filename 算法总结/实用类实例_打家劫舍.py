#-----------打家劫舍1-----------------
'''
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2:
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。

'''
#----------分析------------
'''
由于小偷不能偷相邻房屋，因此容易让人联想到对奇数偶数元素求和的方法。但是仔细想想这道题又不能完全用奇偶数的方法，
例如[3,1,1,5,1,7,1]这样的房屋排列，无论小偷偷奇数位置的房屋还是偶数位置的房屋都不能偷得最多的钱。
所以小偷不是只能偷相隔一间的房屋，还可以选择相隔两间的（这样求和的元素就是奇偶混杂的），
但是如果相隔两间以上就没必要了，因为这中间的房屋只要不相隔都是可以偷的。

'''

#------>>>动态规划的方法-------------
'''
偷到第i个房屋可能是跨过了前面两个房屋（第i-3个），也可能是跨过了前面一个房屋（第i-2个）。
dp[i]表示偷完第i个房屋持有的总现金，nums[i]表示第i个房屋内的现金，
公式就是：dp[i] = max(dp[i-2]+nums[i], dp[i-3]+nums[i])

然后就是初始化dp数组的问题。dp[0]自然就是偷第一个房屋的现金数，没有什么好选择的，因此dp[0] = nums[0]，同理dp[1] = nums[1]。
而偷到第三个房屋只能是偷完第一个房屋过来，所以dp[2] = nums[0] + nums[2]。
最后在返回结果时要注意，因为偷最后一个房屋和偷倒数第二个房屋肯定是不一样的偷法，不知道哪种偷的更多，因此直接返回最大值即可。

'''
def rob(self, nums: List[int]) -> int:
    n = len(nums)
    if n == 0:
        return 0
    if n <= 2:
        return max(nums)
    i = 3
    dp = [nums[0]] + [nums[1]] + [nums[0] + nums[2]] + [0] * (n-3)
    while i < n:
        dp[i] = max(dp[i-2]+nums[i], dp[i-3]+nums[i])
        i += 1
    return max(dp)

#--->>>>另一种动态规划方程---> dp[i] = max(dp[i-1],dp[i-2]+nums[i-1])

def rob(self, nums: List[int]) -> int:
    n = len(nums)
    if n == 0: 
        return 0
    dp = [0] * (n + 1)
    dp[1] = nums[0]
    for i in  range(2,n + 1):
        dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
    return dp[-1]

#-----打家劫舍2-------
'''
你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。
同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

示例 1:
输入: [2,3,2]
输出: 3
解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

示例 2:
输入: [1,2,3,1]
输出: 4
解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。

'''
#------参考解法---------------
#------动态规划---------------
'''
前一例题的升级，加入限制条件-->第一间屋子和最后一间屋子不能同时被抢。即，要么抢第一间，要么抢最后一间。

因此，可以把问题拆分为两个基础版的 打家劫舍：
1、去掉第一间，打劫一次
2、去掉最后一间，打劫一次
3、取两次打劫能获得的最大值

对于基础版打家劫舍而言，设打劫到第 i 家的最大收益为 dp[i]，则有----->>> dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])  

'''
def rob(self, nums: List[int]) -> int:
        
    length = len(nums)   # 终止出口
    if length == 0:
        return 0
    if length == 1:
        return nums[0]
    if length == 2:
        return max(nums[0], nums[1])
    
    def rob_action(nums):  #  规划函数
        length = len(nums)
        dp = [0 for _ in range(length)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, length):
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])
        return dp
    
    # 去掉第一间
    nums1 = nums[1:]
    dp1 = rob_action(nums1)
    # 去掉最后一间
    nums2 = nums[:-1]
    dp2 = rob_action(nums2)
    
    return max(dp1[-1], dp2[-1])

#------>>>>>参考解2------
'''
数组是个环，也就是说偷第一家，最后一家就不能偷；偷最后一家，第一家就不能偷。

所以，我们问题分成求 nums[0:n - 1]或者 nums[1:n]

规划方程---->  dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
'''
def rob(self, nums: List[int]) -> int:

    if not nums : 
        return 0
    if len(nums) == 1: 
        return nums[0]

    def helper(nums):

        if not nums : 
            return 0
        if len(nums) == 1: 
            return nums[0]

        n = len(nums)
        dp = [0] * (n + 1)
        dp[1] = nums[0]
        for i in range(2, n + 1):
            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1])
        return dp[-1]
    return max(helper(nums[1:]), helper(nums[:-1]))

#-----打家劫舍3-------
'''
在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 
除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 
如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:
输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

示例 2:
输入: [3,4,5,1,3,null,1]

     3
    / \
   4   5
  / \   \ 
 1   3   1

输出: 9
解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.

'''
#--->  参考解题------------
'''
从根节点往下可以不断拆分成最优子问题，递归地解决；在回溯过程中汇总左右子树以及根节点的结果。在整个过程中不断更新最大收益。

-----> 动态规划方程
某个树的最大收益 = max（包含根节点的最大收益，以及不包含根节点的最大收益）；

不包含根节点的最大收益 = 左子树的最大收益 + 右子树最大收益

包含根节点的最大收益 = 不包含左子节点的左子树最大收益 + 根节点 + 不包含右子节点的最大收益

maxSum = max（maxSum，当前树的最大收益）

只需后续遍历：其中返回值是抢root的最大金额，不抢root的最大金额。

递归访问后返回二者的最大值

'''
def rob(self, root):
    def postorder(root):
        if root == None:
            return(0,0)

        l = postorder(root.left)
        r = postorder(root.right)
        return(root.val+l[1]+r[1],max(l[0],l[1]) + max(r[0],r[1]))  #如果不抢这个房屋，那么，它的左右子节点抢和不抢都可以，--> max（抢， 不抢）

    r = postorder(root)
    return max(r[0],r[1])
